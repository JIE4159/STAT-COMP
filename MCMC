#python code for MCMC Rayleigh distribution example
import numpy as np
import random
import math
from scipy.stats import chi2
import matplotlib.pyplot as plt

#define target distribution density
def target(x,sigma):
    if x<0 or sigma<0:
        return 0
    else:
        return ((x/sigma**2)*np.exp(-x**2/(2*sigma**2)))

m=10000
sigma=4
x=np.zeros(m)
x[0]=np.random.chisquare(1,1)
k=0
u=np.random.uniform(0,1,m)
for i in range(1,m):
    xt=x[i-1]
    y=np.random.chisquare(xt,1)
    num=target(y,sigma)*chi2.pdf(xt,y)
    den=target(xt,sigma)*chi2.pdf(y,xt)
    if u[i]<num/den:
        x[i]=y
    else:
        x[i]=xt
        k=k+1
print(k)
rejectrate=k/m
print('%s of the candidate points are rejected, the chain is somewhat inefficient with reject rate'%rejectrate)
##display partial part starting at time index 5000

index=list(range(6000,6500))
y1=x[index]
plt.plot(index,y1)

##compare the quantiles of target Rayleigh

b=6000
y2=x[b:m]
plt.hist(y2, 40,density=True)
xvar=np.linspace(0,15,100)
y3=(xvar/sigma**2)*np.exp(-xvar**2/(2*sigma**2))
plt.plot(xvar, y3)

##question 1.2
##Write a Python code for the Bivariate Normal distribution example
##discussed in class using Gibbs sampling algorithm.

#initialize constants and parameters
n=5000
burn=1000
XC=np.zeros((n,2))
rho=-0.75       #correlation 
mu1=0
mu2=2
sigma1=1
sigma2=0.5
s1=np.sqrt(1-rho**2)*sigma1
s2=np.sqrt(1-rho**2)*sigma2
#generate the chain
XC[0,:]=[mu1,mu2]
for i in range(1,n):
    x2=XC[i-1,1]
    m1=mu1+rho*(x2-mu2)*sigma1/sigma2
    XC[i,0]=np.random.normal(m1,s1,1)
    x1=XC[i,0]
    m2=mu2+rho*(x1-mu1)*sigma2/sigma1
    XC[i,1]=np.random.normal(m2,s2,1)
b=burn+1
x=XC[b:n,:]
##compare sample statistics to parameters
np.cov(x[:,0],x[:,1])
np.corrcoef(x[:,0],x[:,1])
x1=x[:,0]
x2=x[:,1]
plt.scatter(x1,x2,alpha=0.5)
plt.xlim(-4,4)
plt.ylim(0,4)
plt.xlabel("x1")
plt.ylabel("x2")
plt.title("Bivariate normal chain generated by Gibbs sampler")

##problem 2.1 problem 9.6, p 277
sizes=[125,18,20,34]
size=sum(sizes)
m=100000
burn=2000

def prob_vector(theta):
    return ((2+theta)/4,(1-theta)/4,(1-theta)/4,theta/4)
def prob_ratio(n,d):
    return (np.prod(np.power(prob_vector(n),sizes)/np.power(prob_vector(d),sizes)))
##random walk metroplis
x_rw=np.zeros(m)
k_rw=0
u=np.random.uniform(0,1,m)
v=np.random.uniform(-0.25,0.25,m)
x_rw[0]=v[0]
for i in range(1,m):
    xt=x_rw[i-1]
    y=xt+v[i]
    if u[i]<prob_ratio(y,xt):
        x_rw[i]=y
    else:
        x_rw[i]=xt
        k_rw=k_rw+1
print(k_rw)
rejectrate=k_rw/m
print('%s of the candidate points are rejected, the chain is somewhat inefficient'%rejectrate)

ids=list(range(burn+1,m,1))
x = x_rw[ids]
# display distribution
plt.hist(x, 20,density= True)

#draw MCMC chain
plt.plot(ids, x)

##problem2.2  problem 9.12, p 278
##based on example 9.6 independent sampler
x0=(0.2,0.4,0.6,0.8)
m=5000
xt=np.zeros(m)
a=1
b=1
n=30
mu=(0,5)
sigma=(1,1)
idx=np.random.choice((0,1),size=n,replace=True,p=[0.2,0.8])
for i in range(n):
    x=np.random.normal(mu[idx[i]],sigma[idx[i]],n)
    
def gelmann(psi):
    n=np.shape(psi)[0]
    k=np.shape(psi)[1]
    psi_means=np.mean(psi,axis=1)  ##row means
    B=n*np.var(psi_means)   ##between variance est  
    psi_w=np.var(psi,axis=0)           ##within variance
    W=np.mean(psi_w)              #within est
    v_hat=W*(n-1)/n+(B/n)        #upper variance est
    r_hat=v_hat/W
    return r_hat

def inde_samp(sigma,m,a,b,x0):
    xt=np.zeros(m)
    xt[0]=x0
    y=np.random.beta(a,b,m)
    u=np.random.uniform(0,1,m)
    for i in range(1,m):
        fy=y[i]*norm.pdf(x,mu[0],sigma[0])+(1-y[i])*norm.pdf(x,mu[1],sigma[1])
        fx=xt[i-1]*norm.pdf(x,mu[0],sigma[0])+(1-xt[i-1])*norm.pdf(x,mu[1],sigma[1])
        r=np.prod(fy/fx)*((xt[i-1]**(a-1) * (1-xt[i-1])**(b-1))/(y[i]**(a-1) * (1-y[i])**(b-1)))
        if u[i]<=r:
            xt[i]=y[i]
        else: 
            xt[i]=xt[i-1]
    return xt
print(inde_samp(sigma,m,a,b,0.2))

#compute diagnostic R
k=4
b=1000
X2=np.zeros((k,m))
for i in range(k):
    X2[i,]=inde_samp(sigma,m,a,b,x0[i])
psi2=X2.T
for i in range(4):
    for j in range(1,m+1):
        psi2[i,]=psi1[i,]/j
print(gelmann(psi2))    ## compute R statistics 

## plot to compare R=1.2
rhat2=np.zeros(n)
for j in range((b+1),n):
    rhat2[j]=gelmann(psi2[:,0:j]) 
plt.plot(rhat2[(b+1):n])
plt.ylabel('Rhat')
plt.axhline(y=1.2, color='r', linestyle='-')
